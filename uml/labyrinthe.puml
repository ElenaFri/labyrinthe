@startuml Labyrinthe

skinparam style strictuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods

class Labyrinthe
{
    + {static} main(args: String[])
}

package views
{
	package helpers {
		'classe fournie ; nous n'avons ajouté que la méthode merge_central(..)
		class ImageHelper {
			+ merge(backgroundPath : String, foregroundPaths : String[*]) : BufferedImage
			+ merge_central(backgroundPath : String, foregroundPaths : String[*]) : BufferedImage
			+ rotate(original : BufferedImage, angle : Double) : BufferedImage
			+ rotateClockwise(original : BufferedImage) : BufferedImage
			+ rotateCounterClockwise(original : BufferedImage) : BufferedImage
		}
	}

	package ViewsForObservers{
	  class GameBoardFacadeView {

              + <<create>> GameFacadeTextView(gameFacade: GameFacade)
              + displayGameState()
              - displayPlayers()
              + onCurrentPlayerChanged(currentPlayer: Player)
              + onPlayerPositionChanged(newPosition: Position)
              + onPlayerObjectiveChanged(objective: integer)

	  }
	}
	
}

package controllers
{

   class GameboardController {

          + <<create>> GameboardController(gameboard : Gameboard)
          + getAvailableMoves(position : Position) : Map<String, Boolean>
          + shiftRow(index : Integer, direction : Integer)
          + shiftColumn(index : Integer, direction : Integer)
          + rotateTile(tile: Tile, direction: integer)
   }
   class GameFacadeController {

          +<<create>> GameFacadeController(gameFacade:GameFacade)
          + getCurrentPlayerPosition() : Position
          + getCurrentPlayerObjective() : String
          + notifyPlayerPosition(position : Position)
          + notifyPlayerObjective(objective: integer)
          + nextPlayer()
          + getCurrentPlayer() : Player

   }

   class UIController {
       + handleTileClick(position: Position)
       + handleObjectiveFound(player: Player)
       + updateView(): void
       + displayGameOver(winner: Player)
   }
}

package models
{
    package observers {
        interface GameFacadeObserver {
            +UpdateCurrentPlayerChanged( currentPlayer : Player);
            +UpdatePlayerPositionChanged(newPosition : Position );
           + UpdatePlayerObjectiveChanged(objective: integer);
        }

        interface GameboardObserver {
            + updateGameboard(gameboard : Gameboard)
        }
    }

	package tiles {
		class TileFactory {
			+ « Create » TileFactory()
			+ createAngledTile() : Tile
			+ createStraightTile() : Tile
			+ createTShapedTile() : Tile
		}

		abstract class Tile {
			# _type : String
			# _hasTreasure : Boolean
			# _treasure : Integer[0..23]
			# _canMove : Boolean
			# _isOnBoard : Boolean
			# _orientation : Integer[0..3]
			+ « Create » Tile()
			+ « Create » Tile(position : Position)
			+ getType() : String
			'récupérer les voies de passage :
			+ getOpenSides() : Sides
			+ getTreasure() : Integer
			+ checkIfTreasure() : Integer
			+ checkIfMoves() : Boolean
			+ setTreasure(treasure : Integer)
			+ {abstract} initOrientation()
			+ {abstract} setOrientation(orientation : Integer)
			+ {abstract} setOpenSides()
		}
		class AngledTile extends Tile {
			+ « Create » AngledTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
		class StraightTile extends Tile {
			+ « Create » StraightTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
		class TShapedTile extends Tile {
			+ « Create » TShapedTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
	}

	package geometry {
		class Sides {
			- _openSides : Boolean[*]
			+ « Create » Sides()
			+ getSides() : Boolean[*]
			+ getSide(i : Integer) : Boolean
			+ setSide(i : Integer, isOpen : Boolean)
			+ isSideOpen(side : Integer
			+ toString() : String {redefines}
		}

		class Position {
			- _x: Integer[0..6]
			- _y: Integer[0..6]
			+ « Create » Position(x: Integer, y: Integer)
			+ getX() : Integer
			+ getY() : Integer
			+ setPosition(x : Integer, y : Integer)
			+ equals(o : Object) : Boolean {redefines}
			+ hashCode() : Integer {redefines} 
			+ toString() : String {redefines}
		}
	}

	package game {
		class GameFacade {
               -  _currentPlayerIndex:integer
               + <<create>> GameFacade()
               + addGameFacadeObserver(gameFacadeObserver : GameFacadeObserver)
               + playerNextObjective()
               + getPlayer(n : Integer) : Player
               + getPlayersPositions() : Position
               + getCurrentPlayerIndex() : Integer
               + getCurrentPlayer() : Player
               + getPlayers() : Player[*]
               + setPlayers(players : Player[*])
               + deal()
               + movePlayer(position : Position, player : Player)
               + nextPlayer()
               + isGameOver() : Boolean
               + getWinner() : Player
               - getInitialPositionForIndex(index : Integer) : Position
               - notifyPlayerPositionChange(newPosition : Position)
               - notifyPlayerObjectiveChange(objective : Integer)
               - notifyCurrentPlayerChange()
		}

		class Gameboard {
               -  random : Random
               + <<create>> Gameboard()
               + getAllAccessibleTiles(start : Position) : Position[*]
               + explore(current : Position, accessibleTiles : Position[*])
               + getNeighbors(current : Position) : Position[*]
               + addGameboardObserver(GameBoardObserver)
               + getTile(position : Position) : Tile
               + getFreeTile() : Tile
               + getObjectivePositions() : Position[*]
               + getObjectivePosition(objectiveId : Integer) : Position
               + setFreeTile(tile: Tile))
               - initializeBoard()
               - placeFixedTiles()
               - placeMovableTiles()
               - placeMovableTileAngled()
               - placeMovableTileTShaped()
               - placeMovableTileStraight()
               - placeMovableTile(tile:Tile)
               - placeObjectives()
               - notifyGameboardChange()
               + shiftRowLeft(rowIndex : Integer) : Boolean
               + shiftRowRight(rowIndex : Integer) : Boolean
			   + shiftColumnUp(colIndex : Integer) : Boolean
			   + shiftColumnDown(colIndex : Integer) : Boolean
			   + getAccessibleTiles(position : Position) : Position[*]
			   + isOppositeSideOpen(position : Position, oppositeSide : Integer) : Boolean
			   + isPositionValid(position : Position)
		}

		class Card {
		    - {final} _treasure : Integer
			- _isFound : Boolean
			' génération du trésor aléatoire, dans la limite des trésors encore disponibles
			+ « Create » Card(treasure : Integer)
			+ getTreasure() : Integer
			+ isFound() : Boolean
			+ getName() : String
			' Un trésor trouvé ne peut pas être re-caché, on ne peut donc pas remettre isFound à false :
			+ setFound()
			+ isBackCard() : Boolean
            + {static} createDeck(): Card[*])
		}

		class Player {
			- _id: Integer[[0..3]
            - _name: String
			- _currentObjectiveIndex: Integer
            + <<create>> Player(id: Integer, name: String)
            + getName(): String
            + getId() : Integer
            + getCurrentObjectiveIndex(): integer
            + getCurrentTile(): Position
            + getLastPosition() : Position
            + getCards(): Card[*]
            + getCurrentObjective(): Card
            + setLastPosition(position : Position)        
            + setCurrentTile(position: Position)
            + setCards(cards: Card[*])
            + completeCurrentObjective()
            + hasCompletedAllObjectives() : Boolean
            + toString() : String {redefines}
		}
    }

    package data {
		class ImageStore {
			    -  _tileImages : BufferedImage[]
                -  _cardImages : BufferedImage[]
                -  _treasureImages:BufferedImage[]
                -  _pieceImages : BufferedImage[]
                -  _handBackground : BufferedImage

                + <<create>> ImageStore()
                + getTileImage(index: integer,direction: integer, withtreasure: boolean,indextreasure: integer) : BufferedImage
                + getCardImage(index :integer, isOpen: boolean) : BufferedImage
                + getPieceImage(index : Integer) : BufferedImage
                + getHandBackground() : BufferedImage
                + getScreen(isRunning : boolean) : BufferedImage
                - chargerImagesPourTuiles() : BufferedImage[]
                - chargerImagesPourCartes() : BufferedImage[]
                - chargerImagesPourTresors() : BufferedImage[]
                - chargerImagesPourPions() : BufferedImage[]
                - chargerImageDeFond() : BufferedImage
                - loadImage( chemin: String) : BufferedImage
		}

		class Screen {
		    - _mainScreen : BufferedImage
            -  _gameoverScreen : BufferedImage
            + << create>> Screen()
            + getScreenImage(isRunning: boolean) : BufferedImage
			'si le jeu est toujours en cours, retourner l'écran principal :

		}
	}
}

Labyrinthe ..> GameBoardFacadeView

GameFacade "1" *--> "4\n - _players" Player
GameFacade "1" o--> "*\n - _gameFacadeObservers" GameFacadeObserver
Gameboard "1" o--> "7x7\n - _tiles" Tile
Gameboard "1" *--> "1\n _freeTile" Tile
Gameboard "1" *--> "7x7\n - _visited" Position
Gameboard "1" o--> "1\n - _tileFactory" TileFactory
Player "1" *--> "1\n - _currentTile" Position
Player "1" *--> "1\n - lastPosition" Position
Player "1" *--> "*\n - _cards" Card


@enduml
