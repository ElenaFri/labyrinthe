@startuml Labyrinthe

skinparam style strictuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods

class Labyrinthe
{
    + {static} main(args: String[])
}

package views
{
	package helpers {
		'classe fournie :
		class ImageHelper {
			+ merge(backgroundPath : String, foregroundPaths : String[*]) : BufferedImage
			+ rotate(original : BufferedImage, angle : Double) : BufferedImage
			+ rotateClockwise(original : BufferedImage) : BufferedImage
			+ rotateCounterClockwise(original : BufferedImage) : BufferedImage
		}
	}
}

package controllers
{
   class TileController {


           + getAvailableMoves(playerId: Integer): List<Tile>
       - _freeTile : Tile
       + shiftRow(index : Integer, direction : String)
       + shiftColumn(index : Integer, direction : String)
       + rotateTile(tile : Tile, orientation : Integer)
   }
   class PlayerController {

       + movePlayer(playerId: Integer, destination: Tile): Boolean
           + rotatePlayer(playerId: Integer, direction: Integer): Boolean
   }
   class CollectorObjectiveController {



       + checkObjectiveCompletion(playerId: Integer): Boolean
       + updateObjectives(playerId: Integer)
       + collectItem(playerId: Integer, itemId: Integer): Boolean
   }
   class UIController {
       - _view: GameView
       - _gameController: GameController

       + handleTileClick(position: Position)
       + handleObjectiveFound(player: Player)
       + updateView(): void
       + displayGameOver(winner: Player)
   }


}

package models
{
	package tiles {
		class TileFactory {
			+ « Create » TileFactory()
			+ createAngledTile() : Tile
			+ createStraightTile() : Tile
			+ createTShapedTile() : Tile
		}

		abstract class Tile {
			# _type : String
			# _hasTreasure : Boolean
			# _treasure : Integer[0..23]
			# _canMove : Boolean
			# _isOnBoard : Boolean
			+ « Create » Tile()
			+ « Create » Tile(position : Position)
			+ getType() : String
			'récupérer les voies de passage :
			+ getOpenSides() : Sides
			+ getIfTreasure() : Boolean
			+ checkIfTreasure() : Integer
			+ checkIfMoves() : Boolean
			+ setTreasure(treasure : Integer)
			+ {abstract} setOrientation()
		}
		class AngledTile extends Tile {
			- _orientation : Integer[0..3]
			+ « Create » AngledTile()
			+ setOrientation() {implements}
		}
		class StraightTile extends Tile {
			- _orientation : Integer[0,1]
			+ « Create » StraightTile()
			+ setOrientation() {implements}
		}
		class TShapedTile extends Tile {
			- _orientation : Integer[0..3]
			+ « Create » TShapedTile()
			+ setOrientation() {implements}
		}
	}

	package geometry {
		class Sides {
			- _openSides : Boolean[*]
			+ « Create » Sides()
			+ getSides() : Boolean[*]
			+ setSide(i : Integer, isOpen : Boolean)
		}

		class Position {
			- _x: Integer[0..6]
			- _y: Integer[0..6]
			+ « Create » Position(x: Integer, y: Integer)
			+ getX() : Integer
			+ getY() : Integer
			+ setPosition(x: Integer, y: Integer)
		}
	}

	package game {

		class GameFacade {
            + « Create » GameFacade()
            'On instancie les cartes et on fait l'attribution ici
            + getPlayer(n : Integer) : Player
            + deal()
		}

		class Gameboard {
            + « Create » Gameboard
            'Et pour la tuile libre ? (-1, -1) ?
            + getTile(position : Position)
		}
		'class Hallway {}

		class Card {
		    - _treasure : Integer
		    ' si l'objectif est rempli
			- _isFound : Boolean
			' génération du trésor aléatoire, dans la limite des trésors encore disponibles
			+ « Create » Card()
			+ generateTreasure()
            + getTreasure() : Integer
            + checkIfFound() : Boolean
            ' Un trésor trouvé ne peut pas être re-caché, on ne peut donc pas remettre isFound à false
            + setFound()
		}

		class Player {
			- _id : Integer[0..3]
			- _name : String
			+ « Create » Player
			+ getName() : String
			+ getCurrentTile() : Position
			+ getCards() : Card[*]
			+ setCurrentTile(x : Integer, y : Integer)
			+ setCards()
		}
    }

    package data {
		class ImageStore {
			'pour chaque tuile, ses positions :
			- _tileImages : BufferedImage[*][*]
			 'recto et verso de la carte, sans dessin :
			- _cardImages : BufferedImage[*]
			'à superposer avec les tuiles et les cartes :
			- _treasureImages : BufferedImage[*]
			'4 pions de couleurs différentes :
			- _pieceImages : BufferedImage[*]
			'zone joueur :
			- _handBackground : BufferedImage
			+ « Create » ImageStore()
			+ getTileImage(index : Integer, orientation : Integer, withTreasure : Boolean) : BufferedImage
			+ getCardImage(index : Integer, isOpen : Boolean) : BufferedImage
			+ getPieceImage(index : Integer) : BufferedImage
			+ getHandBackground() : BufferedImage
			+ getScreen(isRunning : Boolean) : BufferedImage
		}

		class Screen {
			- _mainScreen : BufferedImage
			- _gameoverScreen : BufferedImage
			+ « Create » Screen()
			'si le jeu est toujours en cours, retourner l'écran principal :
			+ getScreenImage(isRunning : Boolean) : BufferedImage
		}
	}
}

Labyrinthe ..> views
views ....> ImageStore
views ....> GameFacade
views ....> Gameboard
views .> controllers
controllers ..> models

'Gameboard "1" *--> "6\n _hallways" Hallway
Gameboard "1" *---> "1\n _tileFactory" TileFactory
Player "1" *-> "6\n _hand" Card
Player "1" *--> "1\n _position" Position
GameFacade "1" *--> "4\n _players" Player
GameFacade ..> Card
ImageStore "1" *--> "1\n _screen" Screen
Tile "1" o-> "1\n # _position" Position
Tile "1" *-> "1\n # _openSides" Sides
TileFactory ..> AngledTile
TileFactory ..> StraightTile
TileFactory ..> TShapedTile
TileFactory ..> Tile
TileController "1" *--> "1\n _GameBoard" Gameboard
TileController "1" *--> "1\n _GameFacade" GameFacade
PlayerController "1" *--> "1\n _GameFacade" GameFacade
CollectorObjectiveController "1" *--> "1\n _GameFacade" GameFacade
@enduml
