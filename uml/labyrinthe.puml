@startuml Labyrinthe

skinparam style strictuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods

class Labyrinthe
{
    + {static} main(args: String[])
}

package views
{
	package helpers {
		'classe fournie ; nous n'avons ajouté que la méthode merge_central(..)
		class ImageHelper {
			+ merge(backgroundPath : String, foregroundPaths : String[*]) : BufferedImage
			+ merge_central(backgroundPath : String, foregroundPaths : String[*]) : BufferedImage
			+ rotate(original : BufferedImage, angle : Double) : BufferedImage
			+ rotateClockwise(original : BufferedImage) : BufferedImage
			+ rotateCounterClockwise(original : BufferedImage) : BufferedImage
		}
	}

	package ViewsForObservers{
	  class GameBoardFacadeView {

              + <<create>> GameFacadeTextView(gameFacade: GameFacade)
              + displayGameState()
              - displayPlayers()
              + onCurrentPlayerChanged(currentPlayer: Player)
              + onPlayerPositionChanged(newPosition: Position)
              + onPlayerObjectiveChanged(objective: integer)

	  }
	}
	
}

package controllers
{

   class GameboardController {

          + <<create>> GameboardController(gameboard : Gameboard)
          + getAvailableMoves(position : Position) : Map<String, Boolean>
          + shiftRow(index : Integer, direction : Integer)
          + shiftColumn(index : Integer, direction : Integer)
          + rotateTile(tile: Tile, direction: integer)
   }
   class GameFacadeController {

          +<<create>> GameFacadeController(gameFacade:GameFacade)
          + getCurrentPlayerPosition() : Position
          + getCurrentPlayerObjective() : String
          + notifyPlayerPosition(position : Position)
          + notifyPlayerObjective(objective: integer)
          + nextPlayer()
          + getCurrentPlayer() : Player

   }

   class UIController {
       + handleTileClick(position: Position)
       + handleObjectiveFound(player: Player)
       + updateView(): void
       + displayGameOver(winner: Player)
   }
}

package models
{
    package observers {
        interface GameFacadeObserver {
            + updateCurrentPlayerChanged(currentPlayer : Player);
            + updatePlayerPositionChanged(newPosition : Position );
            + updatePlayerObjectiveChanged(objective: integer);
        }

        interface GameboardObserver {
            + updateGameboard(gameboard : Gameboard)
        }
    }

	package tiles {
		class TileFactory {
			+ « Create » TileFactory()
			+ createAngledTile() : Tile
			+ createStraightTile() : Tile
			+ createTShapedTile() : Tile
		}

		abstract class Tile {
			# _type : String
			# _hasTreasure : Boolean
			# _treasure : Integer[0..23]
			# _canMove : Boolean
			# _orientation : Integer[0..3]
			+ « Create » Tile()
			+ « Create » Tile(position : Position)
			+ getTileIndex(tile : Tile) : Integer
			+ getType() : String
			+ getOrientation() : Integer
			+ getPosition() : Position
			'récupérer les voies de passage :
			+ getOpenSides() : Sides
			+ getTreasure() : Integer
			+ checkIfTreasure() : Boolean
			+ checkIfMoves() : Boolean
			+ setTreasure(treasure : Integer)
			+ setCanMove()
			+ {abstract} initOrientation()
			+ {abstract} setOrientation(orientation : Integer)
			+ {abstract} setOpenSides()
		}
		class AngledTile extends Tile {
			+ « Create » AngledTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
		class StraightTile extends Tile {
			+ « Create » StraightTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
		class TShapedTile extends Tile {
			+ « Create » TShapedTile()
			+ initOrientation() {implements}
			+ setOrientation(orientation : Integer) {implements}
			+ setOpenSides() {implements}
		}
	}

	package geometry {
		class Sides {
			- _openSides : Boolean[*]
			+ « Create » Sides()
			+ getSides() : Boolean[*]
			+ getSide(i : Integer) : Boolean
			+ setSide(i : Integer, isOpen : Boolean)
			+ isSideOpen(side : Integer
			+ toString() : String {redefines}
		}

		class Position {
			- _x: Integer[0..6]
			- _y: Integer[0..6]
			+ « Create » Position(x: Integer, y: Integer)
			+ getX() : Integer
			+ getY() : Integer
			+ setPosition(x : Integer, y : Integer)
			+ equals(o : Object) : Boolean {redefines}
			+ hashCode() : Integer {redefines} 
			+ toString() : String {redefines}
		}
	}

	package game {
		class GameFacade {
               -  _currentPlayerIndex:integer
               + <<create>> GameFacade()
               + addGameFacadeObserver(gameFacadeObserver : GameFacadeObserver)
               + playerNextObjective()
               + getPlayer(n : Integer) : Player
               + getPlayersPositions() : Position
               + getCurrentPlayerIndex() : Integer
               + getCurrentPlayer() : Player
               + getPlayers() : Player[*]
               + setPlayers(players : Player[*])
               + deal()
               + movePlayer(position : Position, player : Player)
               + nextPlayer()
               + isGameOver() : Boolean
               + getWinner() : Player
               - getInitialPositionForIndex(index : Integer) : Position
               - notifyPlayerPositionChange(newPosition : Position)
               - notifyPlayerObjectiveChange(objective : Integer)
               - notifyCurrentPlayerChange()
		}

		class Gameboard {
               -  random : Random
               + <<create>> Gameboard()
               + getAllAccessibleTiles(start : Position) : Position[*]
               + explore(current : Position, accessibleTiles : Position[*])
               + getNeighbors(current : Position) : Position[*]
               + addGameboardObserver(GameBoardObserver)
               + getTile(position : Position) : Tile
               + getFreeTile() : Tile
               + getObjectivePositions() : Position[*]
               + getObjectivePosition(objectiveId : Integer) : Position
               + setFreeTile(tile: Tile))
               - initializeBoard()
               - placeFixedTiles()
               - placeMovableTiles()
               - placeMovableTileAngled()
               - placeMovableTileTShaped()
               - placeMovableTileStraight()
               - placeMovableTile(tile:Tile)
               - placeObjectives()
               - notifyGameboardChange()
               + shiftRowLeft(rowIndex : Integer) : Boolean
               + shiftRowRight(rowIndex : Integer) : Boolean
			   + shiftColumnUp(colIndex : Integer) : Boolean
			   + shiftColumnDown(colIndex : Integer) : Boolean
			   + getAccessibleTiles(position : Position) : Position[*]
			   + isOppositeSideOpen(position : Position, oppositeSide : Integer) : Boolean
			   + isPositionValid(position : Position)
		}

		class Card {
		    - {final} _treasure : Integer
			- _isFound : Boolean
			' génération du trésor aléatoire, dans la limite des trésors encore disponibles
			+ « Create » Card(treasure : Integer)
			+ getTreasure() : Integer
			+ isFound() : Boolean
			+ getName() : String
			' Un trésor trouvé ne peut pas être re-caché, on ne peut donc pas remettre isFound à false :
			+ setFound()
			+ isBackCard() : Boolean
            + {static} createDeck(): Card[*])
		}

		class Player {
			- _id: Integer[[0..3]
            - _name: String
			- _currentObjectiveIndex: Integer
            + <<create>> Player(id: Integer, name: String)
            + getName(): String
            + getId() : Integer
            + getCurrentObjectiveIndex(): integer
            + getCurrentTile(): Position
            + getLastPosition() : Position
            + getCards(): Card[*]
            + getCurrentObjective(): Card
            + setLastPosition(position : Position)        
            + setCurrentTile(position: Position)
            + setCards(cards: Card[*])
            + completeCurrentObjective()
            + hasCompletedAllObjectives() : Boolean
            + toString() : String {redefines}
		}
    }

    package data {
		class ImageStore {
			-  _tileImages : BufferedImage[*]
            -  _cardImages : BufferedImage[*]
            -  _treasureImages:BufferedImage[*]
            -  _pieceImages : BufferedImage[*]
            -  _handBackground : BufferedImage
            + <<create>> ImageStore()
            + getCardWithTreasure(index : Integer, isOpen : Boolean) : BufferedImage
            + getTileImage(index: Integer, direction: Integer, withtreasure: Boolean,indextreasure: Integer) : BufferedImage
            + getPieceImage(index : Integer) : BufferedImage
            + getHandBackground() : BufferedImage
            + getPlayerIcon(index : Integer) : BufferedImage
            + getGameBoardBackground() : BufferedImage
            + getCardBackImage() : BufferedImage
            + getCardImage() : BufferedImage
            + getCardImagePath(card : Card) : String
            - chargerImagesPourTuiles() : BufferedImage[*]
            - chargerImagesPourCartes() : BufferedImage[*]
            - chargerImagesPourTresors() : BufferedImage[*]
            - chargerImagesPourJoueurs() : BufferedImage[*]
            - chargerImagesPourPions() : BufferedImage[*]
            - chargerImageDeFond() : BufferedImage
            - chargerImageFondTableau() : BufferedImage
            - loadImage(path : String) : BufferedImage
		}
	}
}

Labyrinthe ..> GameBoardFacadeView

GameBoardFacadeView "1" o--> "*\n - _clickedTiles" Position
GameBoardFacadeView "1" o--> "1\n - _gameboard" Gameboard
GameBoardFacadeView "1" o--> "1\n - _gameFacade" GameFacade
GameBoardFacadeView "1" *--> "1\n - _imageStore" ImageStore

GameFacade "1" *--> "4\n - _players" Player
GameFacade "1" o--> "*\n - _gameFacadeObservers" GameFacadeObserver
Gameboard "1" o--> "7x7\n - _tiles" Tile
Gameboard "1" *--> "1\n _freeTile" Tile
Gameboard "1" *--> "7x7\n - _visited" Position
Gameboard "1" o--> "1\n - _tileFactory" TileFactory
Player "1" *--> "1\n - _currentTile" Position
Player "1" *--> "1\n - lastPosition" Position
Player "1" *--> "*\n - _cards" Card
Tile "1" *--> "1\n - _openSides" Sides
Tile "1" *--> "1\n - _position" Position
TileFactory ..> Tile

@enduml
